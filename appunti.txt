04/10/2019

TIPOLOGIE DI ATTACCO

-ip spoofing/maschereding:
	
	si fa finta di essere qualcun altro, falsificando l'ip address. (sbagliato proteggersi limitando l'accesso ad alcuni ip, si adottano altre tipologie di difesa)

.packet sniffing:
	
	lettura dei pacchetti destinati ad un altro nodo della rete, puo avvenire tramite la porta di mirroring --> fondamentale proteggere l'apparato fisico, reti non broadcast, crittografare il payload

-denial of service (DoS):
	
	impegnare l'host impedendogli di fornire il servizio
		-saturazioen della posta/log
		-ping flooding ->> (ping usa icmp(lvl 4) echo req ->, echo reply <- 8byte ognuno) si
		 sfrutta il fatto che icmp è dentro un pacchetto ip la cui max_payload = 64kB quindi si manda dentro ping un payloaf di 64kB. Non ci si puo difendere ma si puo prevenire monitorando le risorse a rischio di saturazione

-DDoS (Distribuited Denial of Service):

	n nodi chiamati daemon/zombie innescano l'attacco. Si crea una botnet. Ci deve essere un master che controlli i vari nodi della botnet --> comunicazioni cifrate (canali coperti che si autoaggiornano per evitare che si venga sgamati (strano ricevere del traffico cifrato)) su c/s o p2p

	miglioramenti: riflettori per nascondere le proprie tracce o per moltiplicare gli attacanti. Fattore di amplificazione |resp| >> |req| 

-Shadow server:
	
	qualche nodo di rete si pone come se fosse lui il fornitore del servizio senza averne il diritto

-MITM/connection hijaking/data spoofing:
	
	prende il controllo di un canale di comunicazione, intercettando il traffico.
	mitm fisico --> ci si attacca al router
	mitm logico --> modifiche tabelle di routing per dirottare un host verso l'attaccante

	Contromisure: auth non basta dato che la peer auth viene fatta al apertura del canale ==> il controllo va fatto ad ogni singolo pacchetto che deve godere della proprieta della riservatezza, integrita, autenticazione e serializzazione (fare in modo che i pacchetti arrivino esattamente nel ordine desiderato (cd /tmp, rm -rf *))

-MITB (man in the browser): https prottegge bene il canale quindi gli stronzi ti entrano 
	nel terminale installando estensioni per fotterti tipo keylogger come parte di videogioco o estensione del browser


07/10/2019

Malware 

	-virus: provoca danni dove è iniettato, e si propaga in altri sistemi
	-worm: si autoreplica al inifinito saturando risore propagandosi in automatico

	trojan --> vettore di di malware

	rootkit --> insieme di strumenti per divantare root di un sistema per avere accesso privilegiato alle risorse


	richede complicità (involontaria) della vittima -> alternative(posta elettronica)(ex: .vbs dentro .pdf corrotto)


	-ransomware: malware orientato a chiedere un riscatto, sbloccati non sempre (dopo il pagamento di un riscatto).
	-ransomware-as-a-service: tox malware(server su rete anonima TOR) 20% di commissione per gestire il tutto 

Contromisure tecniche:

	-dati cifrati? --> backup, di quanto tempo fa?(ransomware silente) --> bkp offline o in rete? sempre offline! --> bkp verificato o alla speruma bin?fare prove di disastro se funziona subito! --> è fondamentale saper datare il momento dell'attacco

Problemi non tecnologici:

	-awarness (kevin mitnick libro da leggere sugli hacker)
	--> social engineering --> phishing

come fare un virus:
	-eseguibile statico senza dipendenze esterne 

-cyber intrusion kill chain (slide 99 pkg 1) 
	difesa: 

CONCETTI BASE DI SICUREZZA
	
Crittografia -> trasformazioni mediante chiavi di plain text P

principio di kerchoffs -> se le chaivi sono tenute segrete, gestite solo da sitemi fidati e di lunghezza adegutata ==> non ha alcuna importanza che gli algoritmi di crittografia siano tenuti segreti anzi è bene che siano resi pubblici

Crittografia simmetrica / a chiave segreta -> k1 = k2 chiave unica e comune a mittente e ricevente, basso carico di elaborazione, ok per cifrare na grossa quantità di dati

c = enc(k,p) c= cypher text, k = key, p = plain text

P = dec(k,c) = enc^-1(k,c)

problema: come condividere in modo sicuro la chiave segreta tra le due parti

Ci sono svariati algoritmi simmetrici adatti ad ogni tipo di sistema di elaborazione (l'algoritmo migliore dal sistema dipende da --> performance cpu, contesto ...)

DES è obsoleto, k a 56 bit e blocco di 64
AES è il piu usato e piu recente 128-256 bit con blocco da 128

FUNZIONE XOR
se l'input è casuale allora anche l'output è casuale 50% di probabilita di beccare 0 o 1

DES - Data Encryption Standard
	chiave da 56 bit (+8 bit di parità) = 64
	usa queste 3 operazioni perche pensato per essere efficiente in hardware:
		
		XOR 
		shift
		permutazioni -> non esistono operazioni sw che fanno sta roba

3DES - Triple DES
	modalità EDE (enc-dec-enc) -> applica DES 3 volte con 2 (Keq = 56bit) o 3 chiavi
	(keq=112bit) ANSI x9.52 --> standard di sicurezza per le banche

11/10/2018

ATTACCO MEET IN THE MIDDLE -> per chiavi simmetriche

	-esempio canale pes sniffare le mail del rettore --> mando una mail quindi conosco P  
	 poi sniffo C e conduco l'attacco per scoprire la chiave --> mai usare algoritmi doppi tipo DES

IDEA

	-algoritmo con chiave a 128 bit e blocco da 64 solo per uso commerciale, noto perche usato in PGP(sw contro l'intrusione dei governi nelle comunicazioni), usa lo XOR addizione modulo 16, moltiplicazioni modulo 2^16 + 1. è adatto a un particolare tipo di cpu a 16 bit (spiare le comunicazioni via radio -> vedia ferrari e mclaren)

RC2 - RC4

	-sviluppati da ron rivest, 3/10 volte piu veloci di des, algoritmi segreti proprietari di rsa , (security through obsucrity, non farla mai) 

	-rc2 pubblicato come rfc-2268 => è noto, usa chiave a lunghezza variabile da 8 a 1024 bit (di solito 64), usa blocchi da 64 bit

	-rc4 è sconosciuto ma reverse engineered (dal codice macchina) ARCFOUR

	-di tipo stream

APPLICAZIONE DEGLI ALGORITMI A BLOCCHI

	-vogliono cpu della dimensione del blocchi

	MODALITÀ:

	-Per dati in quantita superiore di un multiplo del blocco 
		ECB
		CBC

	-Per dati in quantita superiore di un multiplo del blocco
		padding
		CFB,OFB
		CTR

	ECB (Electronic code block):

		prendo esattamente un blocco della dim del blocco
		fortemente sconsigliato, non lo si usa MAI
		- P uguali corrispondo C uguali -> grossa lacuna di sicurezza
		- cifra allo stesso modo blocchi identitici
		  soffre del attacco known plaintext
		- possibile effetuare lo swapping di blocchi

		KNOWN PLAIN TEXT:
			-ipotesi: conosco una parola del messaggio (scommetto che c'è quella determinata parola)

			-cifro quella parola con tutte le possibili chiavi e salvo un db di 2^n entry  (chiave - cipher text) dove n sono i bit della chiave

			-si inizia a sniffare il traffico di chipers text C finche non ne becca uno presente nel db -> la chiave di quello beccato sara la chiave di cifratura

			-ci vuole tanto culo per beccare quella parola ==> si va a beccare l'header delle estensioni di quel file da sniffare che è uguale ovunque e sempre in tutto il mondo => il calcolo lo fai sui primi n bit del header di quel dato in quel dato -> la nuova assunzione è che si sappia l'estensione del file da sniffare

	CBC - cipher block chaining

		-prima di fare la cifratura pasticcia il plain text mettendolo in xor con il risultato del blocco precedente

		-è necessario IV - vettore di inizializzazione per pasticciare il primo blocco di plain text

		- per fare la decifratura il mittente deve conoscere sia IV che K, basta fare rifare lo xor per tornare indietro

		-trasmettere IV della dimensione esatta di un blocco gia cifrato con K

		-NONCE number = number used once -> IV non deve essere mai ripetuto e RANDOM

		- si puo sgamare ma richiede un botto di tempo ==> dipende per quanto deve resistere agli attacchi la roba che sin vuole cifrare (rimanere segreta)

		-non puo essere parallelizzato in cifratua, mentre in decifratura si puo -> è piu veloce a decifrare

	PADDING (allineamento)

		-ma se l'ultimo blocco non riempe un blocco intero? si fa padding nel zona di bit rimasta scoperta -> trasmetto piu dati del necessario, c'è un overload 

		METODI DI PADDING:
			il padding deve essere distinguibile dai dati

			-se la lunghezza è nota o ricavabile tipo stringa C -> '/n' aggiungere byte nulli 0x000 0x000 0x000
			-des originale un bit a 1 gli altri a 0
			-ultimo byte pari alla lunghezza del padding
			-un byte con valore 128 e gli altri nulli

			MA COSA SI METTE NEI BYTE NULLI?
				
				padding con lunghezza esplicita:

					-SCHNEIER byte nulli
					-SSH2 byte random
					-PKCS, SSL/TLS byte con vlaore L
					-IPSEC/ESP numero progressivo 1...L
					-byte con valore L-1

				anche se il P è esattamente mmultiplo del blocco si deve comunque aggiungere un bloco di padding altrimenti il ricevente non sa interpretare le cose

	CTS - Ciphertext stealing 
		
		per usare algoritmi a blocchi senza fare padding -> risparmiare sul disco

		-usa il ciphertext dei blocchi precedenti come padding per non aumentare le dimensioni dei dati dopo la cifratura sulle memorie di massa

		esempio con CTS + ECB:

			-divido il penultimo blocco in head e tail, e aggiungo la tail dove manca per coompletare l'ultimo blocco , questo diventa l'ultimo e l'altro che ora è completo va come penultimo

		CTS + CBC

			guarda slide

		CTR (counter mode)

			-random access al cipher text, posso decifrare un blocco a caso del cipher text
			-cifra n-bit alla volta (un gruppo, spesso di un byte)
			-usa un nonce e un counter cifrati e messi in xor col plain text



ALGORITMI SIMMETRICI DI TIPO STREAM

	-algortimo ideale: ONE-TIME-PAD chiavi usa e getta, richiede chiave lunga quanto il 
				   messaggio da cifrare, nei casi reali non ha senso

	- si manda al mittente un seed che usa per generare una chiave pseudo casuale sincronizzata con il ricevente
	-è fondamentale che i bit non vengano scambiati
	-sono velocissimi
	-non trovano campo applicativo dato che sul web si viaggia a pacchetti => blocchi
	-servono soprattutto a cifrare dischi o memorie di massa


14/10/2018


	SALSA20-CHACHA20
		-prof. bernstein, chiavi da 128 o 256 bit, usano le operazioni base ARX (add - rotate - xor), chahca20 è meglio di salsa perche piu veloce e piu sicuro.
		- f(key256,Noncce64,counter64)= 512-bit keystream block, si puo decifrare in O(1) qualunque blocco a caso

		-limite dello stream 256 GB 2^32 blocchi da 64B

	CAMELLIA
		-fatto in giappone, 
		-blocco da 128bit e chiavi da 128/192/256 bit, prestazioni e robustezza di AES
		-da usare in CTR e CTr/CBC-MAC mode

	SEED
		- fa cacaare perche usa active-x
	ARIA
		- simile ad aes, a blocchi da 128, koreano
	GOST
		- russo, blocco da 64 e chiave da 256

	KUZNYECHIK 
		-attualmente adottato da russi, impegato da veraCrypt(sw per cifrare i dischi)


	SUNTO SULLA CRITTOGRAFIA SIMMETRICA:

	chiave singola, condivisa tra coppie o gruppi

		Distribuzioni delle chiavi: 

			-per n persone che vogliono comunicare servono n(n-1)/2 chiavi

			-OOB: Out-Of-Band canale non elettronico, non si trasmette mai la chiave insieme al testo cifrato! (le volte che capita potrebbe essere un attacco, dato che l'antivirus non riesce a leggere il virus cifrato)

		Lunghezza delle chiavi segrete:

			-se l'algoritmo è stato ben progettato e le chiavi sono tenute segrete allora l'unico attacco possibile è il brute force T = 2^nbit tentativi dove nbit è la lunghezza della chiave (principo di kerchof)

			-chiavi di almeno 128 bit, si puoi di meno ma dipende per quanto tempo la roba cifrata deve rimanere segreta.

			SFIDE DES - Ron Rivest:
				2^56 = 72.057.594 miliardi chiavi -> 10k $ per chi riesce a trovarla

				des challenge 2 -> in 60 giorni si decifrare

				la fine del des -> deep crack in due giorni decifra il des (des challenge 3), è fondamentale conoscere il plain text da decifrare
				il DES è muerto nel '99, chiave troppo corta. IETF cambia l' RFC e suggerisce l'uso di 3DES, inizia una gara del governo USA per un nuovo algortimo simmetrico -> AES (Advanced Encryption Standard), 15 candidati 5 finalisti, vince RIJNDAEL nb (iniziato ad essere usato su larga scala solo di recente -> gli algortimi sono come il vino, piu sono invecchiati piu son forti) -> la NASCITA DI AES


	CRITTOGRAFIA A CHIAVE PUBBLICA

	-Chiave privata e chiave pubblica, sono algoritmi lenti usato principalmente per la firma elettronica e per supportare gli algoritmi asimmetrici

		CRITTOGRAFIA ASIMMETRICA

			-Chiavi generate a coppie: (chiave privata) Kpri, (chiave pubblica) Kpub, i dati cifrati con una chiave sono decifrabili con l'altra

			Firma Digitale:
				chiunque puo leggere con la kpub cio che viene cifrato con la kpri di chi l'ha generato -> cio non garantisce sicurezza ma fornisce autenticità e integrita dei dati, dimostra in maniera matematica e inequivocabile che quel messagio è stato generato veramente dal mittente

				- Riservatezza senza segreti condivisi:
					si puo mandare un messaggio segreto cifrando con la kpub del destinatario

			Algoritmi a chiave pubblica:

				- RSA, prodotto di numeri primi, fattorizzazione del risultato,
					breveattato solo in USA

				- DSA , solo per firma digitale gli USA usano dsa che garantisce solo autenticita -> c'è una funzione con perdita dentro dsa (lossy) che impedisce la riservatezza


			RSA

				- trovare due numeri primi, grandi e segreti P e Q dove N = P x Q,
				modulo N
				- si calcola PHI = (p-1)(q-1)
				-esponente pubblico E tale che 1<E<PHI ed E relativamente primo rispetto a PHI
				- esponente privato D = E^-1 mod PHI

				- chiave pubblica = (N,E)
				- chiave privata = (N,D)
				- P e Q sono da eliminare altrimenti sei fottuto

				Rsa puo cifrare solo dati per cui il valore numerico è minore di modulo N

				plaintext < N
				cifratura c = p^E mod N
				decifratura p = x^D mod N
				-ruolo di E e D interscambiabile dato che (x^D)^E mod N = (x^E)^D mod N
				-la complessita delle operazioni dipende dal numero di bit con valore 1 negli esponenti E e D

				(nb x = a mod n  -> il modulo è il resto della divisione intera tra a e n)

				-Aritmetica modulare 

				nel aritmetica normale x = 5 implica x^-1 = 1/5
				nella modulare x = 5 implica x^-1 mod 4 = {5,9,13,...}

				(usare libreria BC su linux) 

				RSA ottimizazioni di calcolo:
				di solito le kpub hanno E = 13,17 o 65537
				le operazioni lente sono quelle fatte con la kpri, grazie al CRT (Chines remainder theorem) permette di velocizzare (4x) le operazioni

				Debolezze di rsa: 

					-mai scegliere esponenti piccoli della kpub con E = 3 se viene invitato a diversi destinatari lo stesso messaggio cifrato allora si puo sgamaere

					- uso della stesa chiave per firma e cifratura
						-> se si firma una roba decifrata con la kpub si decifra il messsagio ( tipo di attacco se viene sniffato il messaggio cifrato)

				Soluzioni alle debolezze:

					......


				Lunghezza delle chiavi pubbliche:

					-512 alcune settimane
					-1024 alcunni mesi
					-2048 sicurezza ragionevole


				DISTRIBUZIONE DELLE CHIAVI PER CRITTOGRAFIA ASIMMETRICA

				-la kpub necessita di autenticità per garantirne la corrispondenza con la kpri -> chi garantisce la corrispendza tra kpub e identità della persona?

					-soluzione1: scambio OOB (es: key party) controllare bene l'identità del possessore
					-soluzione2: distribuzione della kpub all'interno di un certificato
					             a kpub(=certificato d'identità digitale) -> autorità che certifica l'identità


				SCAMBIO CHIAVE SEGRETA MEDIANTE ALGORITMI ASIMMETRICI

				-si cifra la chiave simmetrica da condividere, con la kpub del destinatario. Implementa un key-distribution/key-exchange

				- DIFFIE-HELLMAN : A e B scelgono due inter pubblici p e g tali che p>g>1
						A si inventa un numero x e B y (slide 75), tecnica immune allo sniffing, implemena un key-agreement. Purtroppo non è resistente al mitm -> l'attaccante puo manipolare i dati -> richiede pre autenticazione per proteggersi per avere certezza che quel numero arriva esattemente da quel peer (DH)

				CRITTOGRAFIA A CURVE ELLITTICHE - ECC

					per far fronte alla potenza di calcolo dei computer quantistici, invede del aritmetica modulare si lavora sulla superficie di una curva ellittica 2D -> problema del logaritmo discreto => possibile usare chiavi piu corte 

					-Vecchi algoritmi portabili in ECC:

						ECDSA = firma digitale -> ps3 hacking
						ECDH = key agreement (diffie hellman a curve ellittiche)
						ECIES = key distribution, gener una chiave simmetrica 

			-----------FINE PARTE RISERVATEZZA--------------


17/10/2019

INTEGRITA DEI MESSAGGI e AUTENTICITA ( + IMPO DI RISERVATEZZA )

	certezza che il messaggio sia veramente quello che è stato spedito, e il mittente è davvero chi dichiara di esserem (autenticità), serve un meccanismo per cui il destinatario riesce a capire se il messsaggio è stato manipolato.

	-Digest 

		(non si puo fare un controllo a campione per verificare lintegrita del msg(divina commedia)) => Si calcola il digest, una sorta di riassunto del messaggio.

		E' un riassunto a lunghezza FISSA, deve essere veloce da calcolare (per non perdere troppo tempo), non deve generare collisioni (due testi diversi danno lo stesso digest), impossibile da invertire. Spesso usatto con la crittografia a chiave pubblica, fa largo uso della funzione di HASH

		vedi CRC - ethernet - disco fisso -> questi vanno bene in caso di errori casuali (non in caso di attacco al integrita)

		-Funzioni di hash dedicate:

			divido il msg M in N blocchi M1.....Mn, applico ripetutamente una funzione base (f), ci vuole un Init Vector => è un algoritmo a blocchi

			MD2-MD4-MD5 (MERDA) 
			SHA1: è stato il piu usato poi l'hanno bucato blocco da 512 digest da 160
			FAMIGLIA SHA2:
				sono stati fatti quando hanno attaccato SHA1
				SHA-224
				SHA-256
				SHA-384
				SHA-512 
			SHA-3 (il migliore) -> blocco da 1152-576, digest da 224-512 

		-Lunghezza del digest
			documenti diversi potrebbero generare lo stesso digest (aliasing = collisioni)

			md1 = H(m1)
			md2 = H(m2)
			se m1 != m2 si vorrebbe md1 != md2 sempre,  ma non è cosi

			se l'algortimo è ben ideato => la probabilità di aliasing è -> Pa = 1/2^Nbit
			formula calcolata assumendo ipotesi di rumore bianco (ogni bit ha la stessa probabilita di essere colpito), nella realtà questa ipotesi non vale dato che l'attaccante non mira a caso ai bit 

			=> I classici CRC sono facilmente attaccabili con brute force basta fare 2^nbit tentativi
				=> NO digest corti oggi si consiglian digest da almeno 256bit

			SHA-1 broken:
			dei cinesi nel 2005 hanno trovato una collisione con 2^69 operazioni (meno della metà della lunghezza del digest (160bit))
			
			SHA2-family:
				SHA256 usa una word da 32 bit
				SHA 512 Usa una word da 64bit 
						da scegliere in base all architettura della cpu del PC

			SHA = Standard Hash Algorithm

			SHA-3 usa principi matematici completamente diversi da sha-2 e sha-3

			Il paradosso del compleanno -> Attacco del compleanno

				si basa su un mitm, appena l'attaccanete vede due pacchetti con lo stesso digest scambia due pacchetti => un algortimo di digest a n bit è insicuro quando vengono generati piu di 2^(n/2) digest perche si ha Pa~50% 

				=> la resistenza di un digest 

				Cripto sistema equilibrato quando algoritmo di cifratura simmetrico e digest hanno la stessa resistenza => sha-256 sta bene con aes-128, sha-512 con aes-256


			SHA-3 - dopo una competizione vince Keccak (catch-ack) ha vinto grazie alla semplicita di implementarlo in hardware

			KDF (Key Derivation Function)
				una chiave crittografica deve sessere random( ogni bit deve avere il 50 % di probabilita di essere 0 o 1), ma gli utenti spesso usano password prevedibili => 
				K=KDF(P,S,itc)
				 P = password
				 S = sale
				 itc = numero di iterazioni della funione base

				KDF si basano su funzini di hash crittografico :

					PBKDF2 usa SHA1
						DK = PBKDF"(PRF,PWD,C,sale,DkLen,Dk)
						(WPA2) usa PBKdf2(HMAC-SHA1,pwd,ssid,4096,256)
					HKDF basata su HMAC

	21/10/2019

		Possibili attacchi a pbkdf2 -> Password Hashing competition	

	    Mic,Mac,Mid per garantire l'integrità, l'auntenticita e per evitare attachi replay dei messaggi si aggiunge agli stessi questi codici

	    -Autenticazione tramite cifratura simmetrica

		    Creazione di un MAC (SI STA PARLANDO DI PROTEZIONE DA INTEGRITA e AUTENTICITA DEL MESSAGGIO)
		    		-mittente -> M* = enc(K,M)
		    		-trasmissione -> M||M*
		    		-ricevente -> X = dec(K,M*)
		    		-verifica -> if (X==M) => ok else alarm	

		    		Solo chi conosce K puo conftrontare la copia con l'originale
		    			-Vantaggi -> verifica dell'integrita esatta e non approsimata

		    			-Svanataggi -> usa operazioni molto pesanti (cifratura simmetrica), raddoppiano i dati trasmessi, il tempo sara piu che raddoppiato

	    -Autenticazione tramite digest e cifratura simmetrica

		    Si invia anche un digest cifrato col messaggio:

		    	-mittente H = enc(K,hash(M))
		    	-trasmissione -> M||H
		    	-ricevente X -> dec(k,h)
		    	-verifica if (X == hash(m)) then ok else alarm

		    	Solo chi conosce la chiave pouo confrontare il digest trasmesso con quello clcolato suidati ricevuti

		    		svantaggi -> due operazioni
		    		vantaggi pochi dati aggiuntivi

		    		Sistema soggetto alle collisioni :(


	   -Autenticazione tramite keyed-digest (la soluzione migliore insieme alla prossima)

	   Ora si usa sempre queste tecnica nella realta, calcolo l'hash tramite un digest con chiave (potrebbe essere nienta altro che )

		   		-mittente d = digest(k,m)
		   		-trasmissione M||D
		   		-ricevente d' = digest(k,m)
		   		-verifica if (d == d') then ok else alarm

		   	solo chi conosce K puio calcolare il digest sui dati riceviti

		   	vantaggi
				-una sola operazione (digest)
				-pochi dati aggiuntivi
			(E' il migliore metodo per integrita su connessioni ultra veloci)

			Possibili errori:
				se kd = H(K||M) allora si puo cambiare il messaggio postponendo uno o piu blocchi:

					kd' = H(K||M||M') = f(kd,M')

				se Kd = H(M'|| M || K)


				difese -> inserire tra i dati la lunghezza di M, definire Kd = H(K||M||K), usare un keyed-digest standard cioè HMAC


	HMAC -> non è un algoritmo di HASH! è un modo di usare le funzioni di hash per combinarle con altre chiavi

		quando lo si usa la chiave deve essere almeno grande quanto la dimensione del messaggio
		E' la cosa piu usata ad oggi per calcolare un keyed digest -> guarda slide 110 per dettagli

	CBC-MAC 

		usato dalle banche, sfrutta un algoritmo di cifratutra simmetrica a blocchi in modalità cbc con IV nullo, prendendo come MAC la cifratura dell'ultimo blocco,è sicuro solo se i messaggi hanno lunghezza fissa

	Integrità e Riservatezza come combinarle?


		Authenticate-and-encrypt (A&E)

			invio enc(k1,p) || mac(k2,p) -> attenzione possibile attacco DoS (dato che si deve sempre decifrare prima di verificare)
			puo fornire info indirette sul plaintext
			(SSH usa esattamente questo schema) 

			-> Isnsicura a meno che sia fatta in un passo solo

		Authenticate-then-encrypt (AtE)

			enc (k1,p || mac(k2,p))

				non da piu info indirette rispetto a prima
				si deve sempre decifrare prima di verificare l'integrita
				usato da SSL e TLS

			->sicura solo con CBC

		Encrypt-Then-Authenticate (EtA)

			enc (k1,p) || mac(k2,enc(k1,p))
			si puo evitare di decifrare se il MAC è errato
			usato da IPsec

			-> la combinazione piu sicura ma bisogna fre attenzzione agli errori di implementazione
				includere sempre nel MAC l'IV e gli algoritmi


		Authenticated Encryption (nuovo challenge per fare algortitmi migliori) - AE

			-Unica operazione per riservatezza + autenticazione(ed integrità)
			-I normali schemi di cifratura se on-line sono soggetti ad attacchi chosen-ciphertext

			RFC 5116 definisce l'interfaccia per AE 

			IGE - INfinite Garble EXtension , algoritmo usato per implentazione di AE, simile a un CBC doppio

			GCM -> il piu popolare, single pass AEAD, parallelizzabile, usato da TLS e openSSL, non è soggetto a DoS, veloce su architetture intel

			OCB 2.0 -> il piu veloce ma poco usato perhce brevettato con GPL, ora libero per usi non militari

			CCM -> off-line double pass 

			NB esempio dell-polito , con chiavi simmetriche non si possono distinguere le due parti chi mi garantisce che il messaggio nn se l'è inviato il receieer a se stesso


		Autenticazione tramite digest e cifratura asimmetrica -> garantisce realmente l'autenticità del sender!

			->FIRMA DIGITALE -> si cifra un hash dei dati con la chiave privata del sender -> utilizzata largamente in tutti i procedimenti commerciali -> la verifica avviene con la chiave pubblica del sender usata nel momento della cifratura (puo essere diverse da quella attuale nel momento della verifica)


			Firme RSA e funzioni di HASH

				una funzione di hash da usarsi in uno schema di firma RSA deve essere:
					- resistente alle collisioni
					- difficile da invertire -> per evitare una falsa firma della chiave pubblica (E,N)

				standard per combinare le cose insieme:

					PKCS1 (public key certificate standard, creati da RSA per creare i suoi algoritmi)


				NB si ha una chiave privata con cui si producono infinite firme digitali( una per ogni documento firmato) => la firma è associato direttamente al documento da firmare

			PROBLEMA: come conoscere la chiave del firmatario nel momento in cui ha firmato un documento?

			=>CERTIFICATO A CHIAVE PUBBLICA:

				Una struttura dati per legare in modo sicuro una chiave pubblica ad alcuni atttributi.
				Lega chiave a identità! Firmato in modo elettronico dal emettitore (CA) certification authority, con scadenza temporale, revocabile sia dall'utente che dall' emettitore

				Formati per certifacti a chiave pubblica:

				X.509:
					v1,v2 (ISO)
					v3 (ISO + IETF)
				non x.509
					PGP(per gli anarchichici che ripudiano gli enti certificatori)
					SPKI
				PKCS#6
					RSA, in parte compatibile con x.509
					obsoleto

			Struttura di un certificato x.509

				-versione
				-serial number
				-signature algorithm del autorità di certificazione
				-issure ente certificatore es: C = it O = polito OU=CA
				-validity
				-subject (chi è il sogetto che controlla la validità)
				-subjectpublickeyinfo
				-CA digital signature (digest del certificato cifrato con la public key)

			Autorita di certificazione - PKI (public key infrastructure)

				è un infrastruttura tecnica ed organizzativa che deve badare ad aspetti tecnici della verifica della chiave -> crea, distribuisce, e revoca certificati a chiave pubblica

				Revoca dei certificati:
					su richiesta del titolare (subject) ->(ad es se viene rubata o si perde la chiave privata)
					autonomamente dal emettitore (issuer) ->(ad es qualcuno si sostiusce alla reale possessore della chiave pubblica -> social engineering attack)

					NB la verifica è a carico del ricevente cioè del (relyng party, RP)

				Meccanismi di revoca:
					CRL (certificate revocation list)
						elenco dei certificati revocati
						firmato dalla CA o da un delegato(per evitare che qualcuno lo modifichi)
						NB l'azione di revoca deve essere fatta istantanemante -> spesso è fatta da terzi

					OCSP (Online certificate status protocol)
						risposta puntuale di un singolo certificato
						firmata dal server
						NB è in grado di rispondere alla domanda solo se il certificato è buono solo nell'istante della richiesta ( nel caso di verifiche di firme passate non piu valide non va bene)

				Verifica di una firma / certificato:

					occorre una gerarchia per verificare chi certifica chi 

					TLCA - top level CA - (trusted)Root CA - è l'unica che si autocertifica => serve un atto di fede

		Valutazione delle prestazioni crittografiche:

			-di base non richiedono molta RAM ma dipendono molto dalla CPU(arch. e instruction set) e dalla dalla cache, le presatzioni non sono un problema sui client ma sui server! => esistono acceleratori crittografici (HSM hardware security module) , acceleratori specifici (SSL, IPsec)
			


	24/10/2019

		NSA consiglia la suite B:

			-per informazioni SBU
					simmetrica: AES-128 e EAS-256
					hash: sha-256 e sha-284
					firma digitale: ecdsa

			-per info fino a livello secret:
					aes128 + sha256+ ec256
			-per top secret
					aes256 + sha284 + ec284

					QUESTO VALE FINO ALLE 2017

		Key escrow -> recuperare la chiave anche senza consenso del utilizzatore (tramite back door) 

		Key recovery -> fondamentaale per la cifratyura simmetrica

		lawfull interception -> tecniche dei governi pre spiare la gente


		TECNICHE E SISTEMI DI AUTENTICAZIONE(authN)

			Alla base di tutto sta l'auth: 
				
				-per definizione: "il processo di verificare una claim (qualcosa che io asserisco/pretendo) che un entità del sistema o una risorsa del sistema ha un ccerto valore per un certo attributo" => (gli esseri umani non sono specificati dato che sono da autenticarsi soprattutto le componenti sw e hw)
				
				-"la verifica del identità di utente/processo/dispositivo" -> si parla del authN di un ATTORE (entità attiva) che potrebbe essere un qualsiasi tip di entità tra umano, sw e hw

			Fattori di authN:

				conoscenza -> knowledge (password, pin ecc ..)
				
				possesso -> ownership (smart card, carta magnetica, smartphnone, token ...), l'oggetto in possesso viene chiamato autenticatore
				
				essenza -> inherence (caratteristiche biologiche)

			Rischi dei fattori:

				conoscenza -> come viene memorizzata? come viene trasmessa per dimostrare l'identità?
				
				possesso -> l'autenticatore stesso, furto, clonazione, uso non autorizzato, malware 0> autenticatore infettato
				
				essenza -> contraffazione(è molot facile clonare l'impronta digitale per lettori scarsi tipo quelli dei cellulari) e privacy(rischio per il reale possessore del essenza che potrebbe essere incrimanto di cose che non ha fatto), non puo essere rimpiazzato quando compromesso, ==> i fattori di essenza devono essere usati solo per sbloccare qualcosa in locale NO SERVER,
				troppo rischioso da mandare in rete


			Modello di autenticazione digitale:

				applicant -> lui che si vorrebbe autenticare
				CSP -> (autenticatore) entita che verifica l'identità e nel caso esegue l'enrollement (credential service provider) emette o registra le credenziali utente

				verifier -> esegue un protocollo di authN

				subscriber -> utente valido del sistema

				relyng party ->uno che fa affidamento sul sistema di auhtn per conoscere l'identita del utente riceve authN assertion

				claimant -> protocollo di authN con cui si palra con un -> verifier una vlta verificato il claimanta il verifier fonrisce al relyng party le info (authN assertion) per dire che quel claimant è ok e puo partecipare alla sessione

28/10/2019

				Autenticazione degli utenti

					Password ripetibili:
						server -> mantiene tabella con Username-password(Puid) oppure username - hash password

							vantaggi:
								semplice per l'utente a codnizione che  ne abbia una sola
							svantaggi:
								conservazione delle password lato utente
								password indovinabile 
								attacchi dit iopo dizionario
							Problemi:
								password sniffing
								password guessing -> molto pericoloso se fatto offline (di solito online si blocca il sistema dopo tot tentaivi)
								password duplication -> non usare mai la stessa pwd per n servizi diversi 
								cryptography ageing
								phishing, mitm, password capture

						suggerimemnti per sceglliere una pwd:

							caratteri miscelate
							lunghe almeno 8 (no limite massimo ma solo minimo)
							parole non presenti nel dizionario 
							cambiate di frequente (1 o 2 volte l'anno)
							non usarle -> sitemi biometrici

						memorizzazione delle pwd:

							lato server
								mai in chiaro 
								pwd cifrata ?il server deve conoscere la chiave in chiaro
								=> memorizzare un digest della pwd(tipo hash)
									questo si presta a un attacco dizionario (provo tutti gli hash) -> attacco velocizzabile con rainbow table
									si deve usare del 'sale' per introdurre una variazione imprevedibile

							lato client
								dovrebbe essere solo nella testa del utente oppure file cifrato (password wallet)

				-Attacco dizionario:

					Ipotesi, algoritmo di hash noto, hash delle pwd noti/leggibili

					pre calcolo : for each word in dict do store(sb,word,hash(word))

					attacco : sia HP l'hash di una pwd
								w = lookup(DB,HP)

								if success then write (pwd = w)
								else write (pwd not in my dictionary)
						si possono trovare db enormi nel deepweb

				-Rainbow table:
					tecnica di trade off tra spazio e velocita (in quello normale massimo spazio velocita minima) 
						tabella perpwd di 12 cifre	
						es: tabella esaustiva = 10^12 righe 
						rainbow = 10^9 righe ognuna rappresenta 1000 pwd
							usa una fuznione di riduzione

						pre calcolo:

							(da riscrivire perche non si è capita)

				per evitare sti attacchi non memorizzare MAI l'hash in chiaro, ma si memorizza l'hash di una pwd che è stato alterato da un sale(un numero random e lungo , uno per ogni utente, meglio se con caratteri poco usati),
				si calcola HP = hash(pwd || salt)
				memorizza la tripla {UID, SALT_uid, HP_uid} in questo modo si evita di avere HP uguale per utenti diversi ma con stessa pwd -> ciò rende impossibile attacchi dizionario dato che dovrebbe essere calcolato un dizionare per ogni sale quindi -> numero di hash delle pwd x 2^nbit_sale

				-> my_sql usa un doppio hash senza sale -> modificare la funzione di memorizzazione pwd

	AUTENTICAZIONE FORTE (strong authN)

		si sta parlando di peer authN (autenticazione al apertuta di una sessione)

		-Definizione ecb: (banca centrale)
			strong customer authN è una procedura basata du due o piu fattori basati si knowledge.owenership,inherence

			gli elementi selezionati devono essere mutalmente indipendenti ( no sbloccare pwd tramite impronta digitale ).

			almeno un elemento deve essere non replicabile

			non deve essere soggetto a furto durante la trasmissione in rete

		-Definizione PCI-DSS (standard per e-commerce)

			v3.2 richiede multifactor auth (MFA) per accessi al CDE (cardholder data environment) per accessi da rete, dagli admin, eccezione: accesso diretto da console(sivìcurezza fisica)

			e per accesso remoto

				da rete untrusted, da utenti, da terze pari

			Dal 01/2018 è obbligatorio


		CHALLENGE-RESPONSE AUTHENTICATION CRA - protocollo a sfida

			una sfida viene inviata al claimant nel momento in cui esso si voglia autenticare , il verifier confronta la risposta con ka soluzione calcolata tramite un sergreto correlato ala claimnant

			problemi:

				la sfida deve essere non-ripetibile per evitare attacchi di tipo replay
				-> si solito la sfida è un random nonce 

				la funzione f deve essere non invertibile, altrimenti un ascoltatore sul canale puo calcolare la chiave usata  kc = f^-1(response,challenge)



			SISTEMI A SFIDA SIMMETRICI- SYMMETRIC CRA

				f == g Kid memorizzata su server e client, schema buono per usare pwd ripetibili senza inviarle in rete

				Kc deve essere nota in chiaro al verifier 

				SCRAM (salted cra mechanism) risolve sto problema usando hash di pwd sul verifier

				attacco possibile : marzullo attack

			SISTEMI A SFIDA ASIMMETRICI

				sono piu pesanti

				il claimant invia il proprio certificato a chiave pubblica, il verifiaer invia un challenge criptato con un numero random X e la chiae pubblica del claimant, il claimant decifra la sfida con la sua chiave  pri e come rispsta invia X, a questo punto il sevrer deve fare una serie di controlli tipo per vedere se quel certificato è valido 

				-non memorizza segreti sul verifier
				-implementato in ipsec, ssh , tls  


			PASSWORD USA E GETTA - OTP

				il server usa una funzione p la quale mettendo l'id del opt e il segreto del utente torna la pwd otp del utente

				password valida solo una volta per il protoccolo di authN

				evita replay e sniffing ma soggetto a MITM => serve authN del verifier senno phishing 

				è difficile fornire le pwd al subscriber così come inserirle dato che sono costituite da caratteri random

				-Come fornire otp agli utenti?

					tramite hw su postazioni stupide/insicure
					tramite sw su postazioni sicure smartphone/tablet/laptop


				-Il sistema S/KEY

					il verifier chiede la password al contrario mentre il subsriber se le calcola a catena da 0 a n-1 in modo che ogni password dipenda dalla precendente

					è un esempio di off-line / pre computed otp


				Time based otp

				la pwd dipende dal tempo e dal segreto dell'utente

				p(ID,t) = h(t,S_id)

				bisogna sempre avere una tolleranza quando si usa il tempo per sincronizzarsi tra client e server => si usa un time slot ed una finestra di autenticazione, una sola authN per timw window elimina il problema del attacco replay (tipicamente 30'', 60'' non buono per alcuni servizi tipo la borsa). Possono esserci attacchi contro il claimant e verifier (esistono generatori di femtocelle che generano l'ora sbagliata al cellulare tipicmente nel futuro cosi l0attacante sa la pwd del futuro) oppure si puo attaccare il server mandando annunci NTP (network time protocol) impostando l'ora sbagliata causando un DoS e volendo un attacco replay se si mette l'ora sbagliata sul server => occhio a NTP sul server

				database critico sul verifier -> se si riesce a rubare il db si possono scoprire tutte le altre pwd

				duress code -> utile sotto minaccia

				RSA securID - architettura -> si deve montare sul server applicativoun client (ace client) che comunichi col verificatore (ace server) per verificare che ogni triade sia corretta

				Event-based otp -> usato in borsa quando servono tante authN per minuto

					usa l'hash di un segreto ed un contatore intero e monotonico => richiede una calcolo localo presso il claimant (es. pulsante), possibile fare auhtn a raffica, possibile pre calcolare l'otp, il verifier deve preveder la possibilita di essere desincronizzato col subscrbr ( pressione non voluta del generatore di pwd)

				Out-of-Band otp

				trasmissione oob della otp (ad es via sms) => serve l'associazione del numero di cellulare con la pwd. All'atto della trasmissione della otp serve un canale sicuro per evitare il MITM, il canale oob è spesso sms quindi è attaccabile per problemi di VoIP, user ID

				-> deprecato sms-oob a favore di un meccanismo push su canale tls verso il dispositivo registrato dell'utente


		ZERO-KNOWLEDGE-PROOF ZKP

			una parte prover dimostra all'altra verifier che una certa affermazione è vera senza fornire altre informazioni

			zkpp (zero knowledge password proof):


		TWO - MULTIFACTORs AUTHN

			uso di piu di un fattore es. pin usato per proteggere l'autenticatore


		Autenticazione di essere umani

			per essere certi che è davvero un umano che si vuole autenticare
				-tecniche captcha
				-tecniche biometriche
				



	31/10/2019

	KERBEROS

		nasce dsal esigneza di utilizzare la crittografia asimmetrico per far fronte al avvento dei pc al posto dei mainframe

			TTP = trusted third party
			realm = dominio di kerberos
			credenziale = user.instance@realm (.instance mai applicato nella pratica -> aveva il compito di definire il ruolo e le autorizzazione dello user, es, admin, normal_user, ...) -> serve a definire in ogni momento i privilegi del utente 

			ticket = struttura dati con cui k gestisce le authN nei confronti del server, un ticket dura 21 ore (v4) o illimitata(v5), è crittografato con una chiave simmetrica DES del server da cui deve essere consumato,è legato al ip del clinet cosi se lo rubano devono anche fare ip spoofing, ogni ticket è legato a una sola credenziale

		ORGANIZZAZIONE DI KERBEROS

			AuthN server -> contiene le chiavi di tutti gli utenti scritte in chiaro (pericoloso!) e conosce la chiave simmetrica del tgs
			Ticket granting server -> contiene le chiavi di tutti i server applicativi

			Procedura:

				lo user chiede al authn server di autetnicarsi il quale chiede al tgs il tgt(ticket granting ticket) che viene mandato cifrato con la chiave dello user. Lo user lo prende decifrandolo con la propria password e lo usa per dire al tgs tutti i servizi a cui vuole accedere per quello specifico server, osicche tgs dara un ticket per ogni servizio richiesto (cosi com'è il sistema è sensibile ad attacco replay se qualcuno riesce a sniffare il tgt o il ticket specifico del servizio).

				Kerberos viene usato da microsoft per gestire le proprie reti, in linux si puo usare come sistema comune din authn tra due diverse postazioni

			Ticket:

				_> solo il server a cui e assoicato puo decifrarlo, 
				contiene -> server-id, client-id, client-address, timestamp, life, chiave simmetrica valida tra user e server a cui è destinato

			Autenticatore:

				contiene -> id del client, ip del client, timestamo, cifrati con la chiave simmetrica tra il client e il sevr cui deve protegfere la comunicaioni da replay e op spoofing


			Richiesta del tgt:

				Tc,tgs -> ticket del client nei confrinti del tgs 
				Kc, tgs -> la inventa l'auth server
				parte gialla -> ticket cifrato con la chiave del tgs (nb dentro il ticket c'è la stessa chiave usata per cifrare il ticket cioè il K tgs), l'unico attacco possibile qua è il DoS 

			Richiesta del ticket:

				La roba in giallo è il tgt(ticket granting ticket)

				il client manda l'id del server a cui vuiole authn, il tgt, un autenticatore con l'ora e cifrato con una chiave tra me e il tgs cosicche non è soggetto a replay e serve a garantire che quel ticket è mandato esattamente in quel instante

				ora il TGS crea un ticket specifico per accedere al server richuesto 

			Uso del Ticket verso il server applicativo:

				come la prima parte di richiesta al tgs con l'autenticatore

				il server si autentica nei confronti del client madando indietro il timestamp del autenticatore +1 cifrato con la chiave comune tra client e server appplicativo

			NB tutti i ticket all interno contengono la chiave simmetrica usata per comunicare tra cliente e server

		Kerberos è un ottima soluzione per sistemi IoT dato che non usa chiavi asimmetriche

		Kerberos fornisce:

			inter realm authentication
			
			forwardable ticket
			
			ticket estesi (dentro il ticket è stata riservata una parte dove ogni ticket server puo aggiungere info aggiuntivie)

			login unico per tutti i servizi kerberizzati


			è ottimo nel caso di connessioni intermittenti dato che i ticket durano tot è l'autenticazione non salta se salta la connessione


		SSO (Single Sign-On)

			fornire all utente un unica credenziale con cui autenticarsi su ogni sistema
			SSO fittizio: 
				Di default c'è dentro il browser

			vero SSO :
				tecniche di auhtn multiapplicazione -> posso uasre un unica credenziale per autenticarmi su piu sistemi

				sso multidominio ( vedi accesso con le credenziali di Fb es. token SAML)

		Interoperabilità dei sistemo di authN -> unico sistema per fare strong authN 
			
			specifiche OAUTH basato su otp 

		HOTP

			K -> chiave segrata condivisa tra autenticatore e verificatore
			c -> contatore
			h -> funzione di has crtittografica a scelta (default sha1)
			sel -> selezione 4 byte da una stringa piu grossa in una maniera nota
					-> 32 bit
			HOTP(k,c) = sel(HMAC-h(K,C)) && 0x7FFFFFFF faccio l'hash con hamac del contatore con la chiave applico la funzione sel e metto i risultato in and con quella roba li

			HOTP CODE viene generato prendendo il risultato di prima in modulo 10^N
			dove n puo essere (6-8)

		TOTP

			come HOTP ms il contantore

			c = (t-t0)/ts dove ts è il time slot entro cui verra generato un unico code , t è lo unixtime(now), t0 è la unix epoch, il ts di default è 30 secondi
			n = 6
			h = sha1(ma puo usare sha256 sha 512)

		Google authenticator

			supporta hotp e totp con:

				k fornita in base 32
				c fornito come uint_64

				sel(x) usa i 4 bit meno significativi di x come offset e torna X[offset...offset+3]

				ts = 30 secondi

				N =6
				se il codice generato ha meno di 6 cifre -> si fa padding a sinsitra con zero


		FIDO

			Fast indentity online
				è uno standard industriale per fare authN biometrica e 2-factor authN.
				deve sapere rispondere a firme asimmetriche e generare firme digitali è basato su dispositivi personali

				si usa come autenticatore un applicativo che genera coppie di achiavi asimmetriche che devono essere approvate dal utente(trimite pin i impronta digitale) alchè la chiave pubblica viene mandata al servere al quale ci si vuole autenticare

				NB usare chiavi diverse permette di proteggere la nostra identita per non essere tracciati(protezione privacy)

				Il login avviene tramite challenge inviata dal server a cui si vuole accedere la risposta alla sfidsa viene mandata cifrandola con la propria chiave privata


				Transazione sicura -> oltre alla risposta viene mandato un testo relativo alla transazione firmato digitalmente cosicche venisse modificata non puo essere accettata

				no phishing perche la risposta puo essere firmata dicendo che sto rispondendo a quel server

				si genera un keypair ad ogni ogni registrazione -> non esiste traccibailità/collegabilità tra servizi deiversi usati dallo stesso utente, account diversi assegnati allo stesso utente

			TPM -> oggetto hw che gestisce chiavi pubbliche e chiavi private 


4/11/2019

SICUREZZA DELLE RETI IP

	Autenticazione dei canali ppp (point to point protocol), protocollo per incapsulare pachertti di lvl 3

		3 fasi sovlte in squenza:
			LCP -> link control prootcol
			authN -> opzionale(PAP, CHAP o EAP)
			L3 encapsulation -> (IPCP, IP control protocol)

	PAP -> primo sistema di auhtn per accessi dial-up ma anche wireless o virtuali
			Password authn protocol

	CHAP -> challenge handshake authn protocolo -> sfida simmetrica basata su password utente

	EAP -> extensible authN protocol(per evitare di sviluppare n protocolli per ogni tipo di roba da proteggere) si aggancia a meccanismi esterni(sfide,otp,tls). Ora si usa solo EAP

	PPP EXTENSIBLE AUTHN PROTOCOL - EAP

	si deve implementare da solo il livello 2 (un proprio protocollo di incapsulamento) 


	ARCHITETTURA

	 eap sta in mezzo tra un qualche cnanale di trasporto (802.3, ppp, 802.11, 802.5) e i vari moduli che offrono il metodo di autenticazione richiesto dal tipo di canale di comunicazione

	 il NAS si appoggia a un server di backend (authenitication server AAA) che effettua l'autenticazione usando un database con le info degli utenti, inoltre se l'utente supera i controlli gli viene assegnata delle configurazioni (e mette l'utente in una vlan per tenerlo separato dalla traffico in rete) 

	 SERVER DI TIPO AAA (authn, autorizzazione, accounting)

	 Protoclli di comunicazione tra nas e authN server-> RADIUS

	 	radius è il piu diffuso e puo funzioinare da proxy

	 	diameter -> evoluzione di radius, supporta roaming tra isp diversi, eleveta attenzione alla sicurezza

	 	tacacs+ -> era meglio di radius ma non open source


	 RADIUS - remote authn dial-in user service (1991)

	 	schema tra nas e as:

	 	timeout e ritrasmissione, flotta di server secondari (pericolo DoS)


	 RADIUS PROXY

	 		il server radius puo fungere da proxy verso altri server di authn (n NAS, m authN server), si possono definrie utenti sepeifichi che sinusano solo us riadius altri per altri server.

	 		dato che radius puo essere usato con qualsiasi protocollo di authN (vedi pap, chap) nei suoi pacchetti potrebbero esserci (nb siamo tra il nas e l'auth server) lo username e la pwd -> serve confidenzialità e privacy (sniffing nas req)

	 		fkase AS resp -> non c'è authN del server finora, si potrebbe usare un fake AS per bloccare o per permettere un ingresso non autorizzato

	 		changing AS resp (cambiare le risp di autorizzazioni per fare le cose di prima)

	 		replay of AS resp

	 		pwd enumeration( from fake NAS ) -> le richieste del nas devono essere autenticate

	 		DoS -> tante richieste da parte di un fake NAS -> server scalability

	RADIUS: protezione dei dati

		integrita e authn dei pacchetti tramite keyed-md5:
			key = shared-secret
			client senza key sono ingorati

		password trasmessa "crittogrfata" con md5 (dopo averne fatto il padding a 128 bit con NULL)

	RADIUS: Paccehtti

		access-request

		access-reject

		access-challenge

		access-accept


	NAI (Network access indetifier) - nel caso di di username = username[@realm]

	esempio chap + radius


	DIAMETER

	protezione obbligatoria con IPsec o TLS

		configurazioni obbligatorie:

			IPsec ESP  per integrita
			TLS per muta authn

	IEEE 802.1x 

		port-based network access control:
			per il livello 2 (MAC)
			utile sugli switch di reti wired
			indispensabile nel casi di reti wireless

		framework per autenticazione e key-management

			siccome puo essere usato per reti wireless il canale puo essrer sniffato molto easy => serve riservatezza della chiave percio puo derivasre chiavi di sessione da usare in authn e integrità e riservatezza

		architettura:

			eapow (eap over wireless) se incapsulato dentro 802.11
			eapol (eap over lan) se incapsualto dentro ethernet
			eapor (eap over radius) incampusao il pacchetto dentro radius 

		vanatggi -> comunicazione diretta tra supplicant e AS , il NAS agisce come 'pass-throug-device' => nessun cabio di nas o nic per implementare nuovi meccanisimim di authN

	EDUROAM -> es di omplentazione di 802.1x

	LIVELLO OTTIMALE?

		piu si sale nello stack piu le funzioni saranno specifiche

	SICUREZZA DEL DHCP

		è un protocollo non autenticato => facilissimo attivare shadow/fake server
			-DoS
			-MITM logico -> fornisco config con subnet da 2 bit + default gw uguale alla macchina che vuole essere mitm -> ogni pacchetto passa dal fake gw, facendo nat si intercettano anche le risposte

		Protezione del dhcp
			alcuni switch offrno dhcp-snooping = solo risposte da trsuted port
			IPguard -> solo ip ottenuti da dhcp

			-RFC-3118 
				usa hmac-md5 per autenticare i messagfi
				poco usato perche serve chiave simmetrica tra user e server dhcp(molto complicato)

		Sicurezza a livello 3 - network

			è il primo livello end-to-end -> protezione end-to-end per reti omogenee a livello logico, oppure tramite vpn per proteggere solo una parte del path

			VPN - virtual private network
				è una tecnica hw o sw per creare una rete privata utilizzando canali e apparati condivisi e NON fidati

				Per realizzare una vpn si puo usare -> tunnetl ip sicuro, reti nascoste

			VPN CON RETI NASCOSTE

				molto pericolose

			VPN mediante tunnel

				i router incapsulano paccheti di rete all interno di altri pacchetti, protezione superabile da chi gestisce i router o da chi puo comunque leggere i paccehtti

				problemi di performance dovuti al doppio payload => frammentazione

			VPN mediante tunneil ip sicuro -> la soluzione migliore

				prima di essere incapsulati i pacchetti vengono protetti con le regole decise dal utente tramite MAC per integrità e authN, cifratura per riservatezza, numerazione per evitare replay -> l'unico tipo di attacco è il DoS se gli algoritmi crittografici sono forti

	IPSEC

		architettura IETF per fare sicurezza a livello 3 sia in ipv4 che ipv6 -> implementazione standard di cio visto prima. ipsec si inventa due formati che apparanetemente sono due protocolli di trasporto che si chiamano AH e ESP

		Pseudo Protocolli

		AH -authn header: fornisce integrita, authn e no-replay	
		ESP - encapsulating security payload: fornisce AH + riservatezza	
		IKE -internet key exchange : per negoziare in rete chiavi simmetriche 

	IPsec security association (SA)
		connessione logica unidrezionale protetta tra due sistemi ipsec, ad ogni sa sono associabili caratteristiche di sicurezza diverse (monodirezionali) => occorrono 2 SA per avere protezione completa di un canale bidirezionale

	DATABASE LOCALI ipsec

		SPD - security policy database

			contiene la security policy da applicare ai diversi tipi di comunicazione - da le info sul traffico da proteggere - puo essere configurato manually

		SAD - SA database

			contiene l'elenco delle sa attive in un certo istante di tempo	

	IPSEC IN TRANSPORT MODE

		usato per fare sicurezza end-to-end => usato dagli host non dal gw, si aggiunge un secondo header ip prima del payload tcp (se c'è qualcosa da progteggere nel header ip di partenza non puo essere protetto)

	IPSEC IN TUNNEL MODE

		si protegge anche l'header ip end-to-end fondamentale che i gw siano in grado di implementer ipsec


	AH - AUTHENTICATION HEADER

		nella prima versione c'era un errore (no-replay) poi aggiunta nella seconda versione che usa HMAC-MD5 

		l'autenticazione è fornita dalla SA negoziata tra i due peer 

		Normalizzazione per AH

			vengono azzerati i campi variabli(in trasmissione) tipo il ttl o se presente il routing header -> se non viene normalizzato il pacchetta è come se fosse stato manipolato

		HMAC-SHA1-96

			slide 57

	ESP - encapsulating security payload

		prima versione solo riservatezza nella seconda versione incoorpora le funzioni di ah 


		esp in transport mode

			si cifra esattamente e solo il payload => non nasconde l'header (si puo sniffare che la cominucazione avviene tra due nodi noti)

		esp in tunnel mode

			si cifra tutto il pacchetto compreso l'header end to end

			in questo modo per gli isp è impossibile fare QoS dato che non è possibile determinare il payload type del pacchetto cifrato

	PROTEZIONE DA REPLAY IN IPSEC

		ipsec non protegge da cancellazione e replay dato che è un azione indistinguibile, per evitare qusto si dovrebbe tenera traccia di ogni pacchetto ricevuto cosa impossibile a livello ip => si usa una finestra limitata che tiene traccia dei pacchetti solo in quella finestra se ad esempio arriva un pacchetto in ritardo fuori dalla finestra si deve decidere se accettarlo o meno, se si accetta però è fondamentale che ci siano controlli a livello piu alto dall'altra parte scartare un pacchetto pensando che potrebbe essere replay comporta un grande overhead nel caso non dovesse essere scartato

	ipsec v3

		ah è opzianle mentre esp è obbligatorio


		TFC traffic flow confidentiality - viene fatto del padding per nascondere la vera dimensione del messagio per cui si potrebbe conoscere il tipo di implementazione usata -> si peggiorano le prestazioni -> supporto per pacchetti dummy (next header 59) quindi normanlemnte tutti i nodi collegati con ipsec trasmettono sempre per confondere le idee a delle potenziali spie



11/11/2019

	John the ripper tool - password cracker

		Attacco dizionario:
			in /usr/share/john/password.lst -> di defualut include un dizionario banale(qualcke KB), uno decente costa qualche decina di dollari nel darkweb (qualche decina di MB)
		Esercizi:
					Stime temporali

SYNTAX PER ESERCIZI

		encyrpt notation	
			E_AES_128_cbc()

		decrypt
			D_aes_128_cbc()

		p = plain text
		c = cipher text

		NB nella funzione di ehash si mette tutto quello che debe esserer passato compreso il tipo di algoritmo usato
		

18/11/2019

	configurazione ipsec:

		-end to end security:
			canale virtuale sicuro ipotesi che gli unici di cui cis i puo fidare sono solo i due host tutto il resto è insicuro => transport mode pacchetti sicurizzato sugli host => non si puo cifrare l'header -> vanno configurati tutti i terminali, di difficile implementazione nel caso di molti host. MIcrosoft ha risolto sto problema in parte dato che utilizza protocolli insicuri di default a livello applicativo, cosi ha sicurizzato lo stratlo sottostante con active directory il quale permette di configuare i nodi con ip sec facilmente. Un altro problema è che non si puo fare intrusion detection del traffico scambiato tra due nodi configurati in transport mode end to end sec.
		-Basic VPN:
			non viene sicurazzato il traffico sui nodi finale ma si assume che una porzione della rete è fidata, si mette un GATEWAY in un certo punto tra la rete fidata e la non fidata, e su questo GATEWAY si mette ipsec in tunnel mode. La banche usano questa soluzione. Fondamentale che la rete interna ritenuta fidata lo è veramente. Si crea un collo di bottiglia immenso dato che quel gateway dovra fare cifratura di n mila host tutti insieme => il gateway va equipaggiata bene. Cosi si puo fare ID nella rete interna 
		-End to end security with basic VPN
			transport mode sugli host + tunnel mode sul gateway , disponibilita di una doppia linea di difesa => si puo vedere come un autenticazione sul terminale e una cifratura sul gateway

		Queste soluzione in caso di monbilita non vanno bene


		-Secure gateway:
			soluzione nel caso di terminali in mobilità, si crea un canale virtuale sicuro tunnel mode tra host e gateway => autenticazione + cifratura

		-Secure remote access:
			doppia protezione tunnel-mode verso il gateway (autenticazione per lingresso in rete) + tunnel transport mode verso un terminale (cifratura + volendo autenticazione) è fondamentale che i terminali abbiano la capacità crittografica e di batteria per eseguire le operazioni di cifratua

		-IPsec key management:
			è necessario configuare i nodi =>ipsec key management è una soluzione che permette di scegliere chiavi e distribuirle:
				-distribuzioone OOB manuale/automatica

			-ISAKMP - internet scurity association and key management protocol
				definisce le procedure per negoziare stabilire escamnbiare le chiavi, non indica il metodo da usare per lo scambio
			-IKE - internet key exchange
				phase1 -> si setuppa una prima SA
					main mode = 6 messaggi, protegge l'identita delle parti
					aggressive mode = non protegge l'identità

				phase2 -> tramite la prima SA si crea una seconda SA piu specifica (tipo comunizione sicura sulla porta 23, 56, udp...)
					quick mode : 3 messaggi
					new group mode: 2 messaggi permette di cambiare l'algortimo e la chiave di cifratura senza interrompere il traffico (dato che puo esserer pericoloso cifrare una grossa mole di dati con lo stesso algoritmo)

				metodi di autenticazione:
					-NON RIPUDIO DELLA NEGOZAZIONE IKE con la firma digitale
					-Public key encryption
						protezione dell identita nell aggressive mode

					-Revised Public 

					-Pre shared key
						l'id della controparte puo essere solo l'ip quindi non va bene per psotazioni mobili

		-VPN concentrator

			apparecchiature special purpose che fungono come terminatori di tunnel ipsec, prestazioni elevate in relazione ai bassi costi

		-requisiti di sitema per ipsec 
			su router cpu potente, non va bene gestirlo in outsourcing
			su firewall cpu potente
			su vpn concetrator : bella soluzione dato che è indipendente dal resto degli elementi => massima indipendenza dalle altre misure di sicurezza

		-Influenza di ipsec sulle prestazioni
			diminuisce il TH di rete. 
			NB non si puo fare compressione a livello piu basso di dove viene fatto ipsec dato che ci fa perdere tempo, rende il pacchetto piu grosso, e fornisce un dizionario di similutidini => mai comprire il pacchette ipsec!! volendo si puo usare ipComp

		-Applicabilita di IPsec
			solo pacchetti unicast, no broadcast, no multicast, no anycast (non sono proteggibili da ipsec). Tra parti che hanno attivato una SA, tramite chiavi condivise o certificati x.509 => gruppi 'chiusi'

	SICUREZZA DI IP

		inidirizzi non autenticati 
		pacchetti non protetti

		sono facilmente attaccabili specialmente i protocolli di servizio (icmp, ...)

		-ICMP
			destination unreacheable: Dos
			source quence = quando i router hanno i buffer pieni chiedono di dimezzare la velocita di trasmissione della source => Dos
			redirect: pacchetto di controllo usato per segnalare nuova destinazione -> ma dato che il pacchetto redirect non è autenticato si puo fare un MITM logico
			time exceeded for a datagram = se si supera 64 hop allora c'è un loop sto messaggio comunica al mittente sto fatto => Dos

		-SMURFING ATTACCK
			tipo di ping bombing : l'attaccante fa finta di essere un nodo A (vittima) e lancia un echo request con destinazione X:Y:255:255 in questo modo ricevera 65000 risposte di tipo echo reply ma non l'attaccante ma la vittima con ip di A

			Contromisure:
				per attacchi dall esterno rifiutare il broadcast IP

				per attacchi interni: identificare l'attaccante tramite network management

		-Fraggle Attack (tcp small services)
				sfrutta servizi diagnostici di livelli diversi da ip (tipo tcp udp), udp/tcp echo request misura le prestazioni bidirezionali, volendo si puo mandare un pacchetto solo di andato collegandosi a una porta chiamata di discard, oppure misurare la durata della risposta sulla porta (-chiedere nome-)

		-ARP poisoning
			usato per scoprire l'indirizzo di l2 di un nodo di cui è noto solo quello di l3

		-TCP SYN flooding
			sfrutta il three way handshake di tcp, l'attaccante mando solo il syn senza mai rispondere con l'ultimo ack, in modo da satutare la tabella di rete della vittima finche non vanno in timeout di solito a 75 secondi nel caso di righe half open (solo con il syn) (fondametnale usare ip spoofing per non farsi sgamare e mandare richieste multiple). Cio comporta che è un attacco a singhiozzo

			Difesa da SYN flooding:
				-abbassare il timeout: rischio di eliminare client validi ma lenti
				-aumentare le dimensioni della tabella: aggirabile con l'invio di piu richieste 
				-usare un router con 'syn interceptor': sostituisce il server nella prima fase =	> quando arrivano i syn è lui che risponde con syn/ack => quindi se mai 
					arrivera l'ack sara lui a comunicarlo al vero server
				-usare router come syn monitor: uccide i pacchetti pendenti(RST)

			SYN cookie
				unico modo per eliminare il problema del syn flooding alla radice.
				ogni volta che c'è un protocollo che richiede che il server mantenga lo stato c'è margine di attacco. Usa il sequence number calcolato in maniera crittografica usando dati del client => quando si riceve l'ultimo pacchetto di ack il server tramite il sequence number puo verificare che è davvero il client a richiedere la coneessione => quindi NO tabella delle connessioni sul server, è il client che si deve ricordare
				Molto spesso non è attivo di default il SYN COOKIE

	Sicurezza del dns:

		terminare i nomi col punto (.) es: www.polito.it. 
		il punto indica il root NS, omettere il punto comporta essere attaccabili a livello di dhcp su puo autoconfiguare il suffisso se non viene messo il punto alla fine del indirizzo => shadow server

		Dns shadow server: se si è in grado di intercettare la domanda che un client fa a un name server, e tramite ip spoofing rispondo al client come falso name server, reindirzzo i client dove voglio (volendo per 15 giorni = durata della cache del nameserver del client)

		DNS cache poisoning
			attirare la vittima a fare una query al proprio NS, fornendo piu risposte a una dns query anche a query effettuate sovraschivendo la cache della vittima

		DNS flash crowd
			in generale flash crowd è analogo del flash mob ma per creare un dos, tutti quanti insieme fanno una domanda al dns di un certo sito


		Traduzione nomi-indirizzi:
			negli os c'è un modulo chiamato name switch che guarda in etc/host per collegarsi a certi indirizzi senza fare dns queries. ALtrimenti viene usato il resolver il quale fa partire il processo di traduzione  

		DNS sec 
			kaninski nel 2008 scopre un nuovo attacco che rende il cache poisoning (di tipo 2) piu facile da fare piu difficile da evitare (dx.doi.org)

			firma digitale dei record dns (il server che genera la risposta la firma, cio elimina il problema del shadow server) , ma chi è authoritative per un certo dominio(chi ha il diritto di fornire la risposta?) serve la lista dei server autorizzati a fornire uqella risposta inoltre serve una pki per la distribuzione dei certificati => dns sec non usa pki, le chiavi pubbliche sono scritte direttamente nel dns quindi ogni volta che fa una richiesta dn il server deve fornire anche la propria chiave pubblica. un attacco possibile di dos è chiedere n indirizzi che non esistono per generare n certificati inutii 

			-- l'indirizzo 8888 di google è multicast -> il router seleziona il server che è piu vicino al client quindi funge da dns (nb che che cosi non vengono cifrate le query) dns over https --

			crittografia sui server dns 

		Sicurezza del routing

			AS cinesi gli as parlano tra di loro con bgp (border gatewy protocolo non autenticato) -> i cinesi hanno iniziato a mandare annunci bgp falsi dicendo che il modo piu veloce per mandare richieste verso gli us era passare verso pechino 

			Filtri per protezione da ip spoofing, configurare i nodi con due regoli fondamentali per limitare i danni dello spoofing sia per i paccheti in entrata che in uscita

	LO STANDARD X.509, LE PKI E I DOCUMENTI ELETTRONICI

		Autorità di certificazione

			se un utente vuole avere un qualche tipo di certificato necessita di un apparecchio che possa cifrare, genera una chiave privata e una pubblica, dopo mnada la pubblica a una ca con gli id a cui vuole associare la key, poi la registration authority fa le verifiche del caso e se va tutto ok comunica alla ca se puo emettere il certificato

			x.509 v 3 è lo standard piu usato per eseguire questo processo di generazione e validazione di un certificato, ci sono due tipi di estensione di certificato
				pubbliche:
				private: mi autodefinisco io da solo, saranno interpratibili solo da una certa comunita di utenti

			estensioni:
				
				critiche: se c'è una certificato marchiato con estensione critica che non conosciamo allora la richiesta va buttata via subito (non sono piu valide le garanzie legali)

				non critiche: in questo caso non è cosi importtante per garantire la transazioni quindi sta al utente se accettare o meno la transazione

				il differente trattamento è interamente a carico di chi effettua la verifica: RELIYNG PARTY

				Estensioni pubbbliche:
					key and policy information -> 
						key usage: identifica lo spazio applicativo per cui questa chiave puo essere utilizzata. Le applicazioni definibili sono non ripudio, cifratura di chiavi, decifratura di dati, firma digitale, key agreement,
						firmare certificati o crl (flag per CA)
					certificate subject and certificate issuer attributes ->
						subject alternative name (SAN) permette di usare id diversi a secondo del servizio 

	25/11/2019

	Firme Digitali:
		a volte sullo stesso documento sono necesarie piu firme
			- primo formato signed data(pkcs7) -> la firma avvolge i dati(envelopping signature)
			- sarebbe meglio avere enveloped signatoure in cui è la firma ad essere avvolta dal documento (es pdf) però se non hai un pdf non puoi firmarlo
			-detached signature -> documento separato dalla firma serve un ptr per associare la firma al documento, però se il doc viene spostato il ptr non si aggiorna => problema!

		Usando le tre tecniche insieme si posso implemntare tecniche di firma multipla

			-In parallelo -> vengono fatte n firme in qualsiasi ordine sul documento (c'è un certo workflow unordered) qui ognuno firma solo il documento
			-Sequenziali/gerarchiche -> quando il workflow deve avere un ordine specifico, allora il cosa si firma cambia (qui ognuno firma il documento con le precedenti firme apposte) 


		Qualified Electronic Signature (QES)

			non so che minchia sia


		Standard ETSI per firma digitale

			standard che dice in che modo va usato pkcs per implementate un firma elettronica digitale avanzata


SICUREZZA DELLE APPLICAZIONI DI RETE

	Sicurezza di canale:
		protezione solo durante il transito nel canale -> la sicurezza è associata alla sicurezza del canale e bom, si puo fare sia singola che mutua authN e negoziare tutte le proprietà di sicurezza tranne il NON RIPUDIO. Tra le soluzione piu usate perche non necessita di modifiche applicative.

	Sicurezza di messaggio:
		la sicurezza è intrinsica del messaggio -> vale sia prima che dopo la trasmissione -> richiede modifche applicative, non si puo mutua authN ma si garantire non ripudio

	Sicurezza interna alle applicazioni:
		ogni app(client/server) condivide le api di accesso allo stack di rete (socket), interoperabilita non garantita

	Sicurezza esterna alle applicazioni:
		si inserisce un nuovo livello di canale logico sicuro sicuro

		SSL/TLS : il piu diffuso al mondo
		SSH: momento di gloria quando gli USA non potevano esportare authN forte
		PCT: proposto e implementato solo da MS, ma faceva cagare


		SSL(secure socket layer):
			protocollo di trasporto sicuro a livello di sessione!
			E' un protocollo a negozazione -> il livello di sicurezza va negoziato tra C e S. Proposto da NETSCAPE 
			garantisce:
			- authN (server, server+client)
			- riservatezza dei messaggi (negoziabile)
			- authN e integrita dei messaggi (non negoziabile)
			- protezione da replay e da filtering (non negoziabile)

			Dato che è un canale tcp arricchito con la sicurezza è facilmente applicabile ad applicazioni basate su tcp tipo http smtp nntp ftp.....

			Authn e integrita 
				il server durante l'apertura dei canale fa dei calcoli per rispondere a una sfida mandatagli dal browser, l'autenticazione del client è opzionale -> Peer Authentication

			Per l'authn e l'integrita dei dati viene usato un keyed digest(sha-1) e un MID per evitare replay

			ssl essendo su tcp da una socurezza maggiore rispetto ad ip sec dato che garantisce che l'ordine dei dati è corretto e non ci sono duplicati (tutte le proprietà garantite da tcp)

			Riservatezza 
				Il client genera una key di sessione usata per la cifratura simmetrica e poi viene comunicata al server o concordata tramite crittografia a k pub


			NB il collegamento potrebbe fallire se il client non sa usare algoritmi di sicurezza richiesti dal server
			1) richiesta https
			2) il cliente comunicaz che algortimi di sicurezza conosce 
			3) il server invia il certificato che deve contenere il nome del url come (subject name) -> un aziende con n applicazioni web deve avere n certificati
			3bis) server challenge response
			4) opzionalmente il cliente puo inviare certificato
			4bis) client challenge response
			5)CANALE SICURO SSL

			In questo modo la sicurezza è garantita a livello di rete NON applicativo


2/12/2019

	DTLS - Datagram transport layer security 
		tls per udp

	Heartbleed
		attacco contro tls, si basa su un estensione che è la cosidetta hearbeat extension(quando c'è una trasmssione se anche aulcuno non deve trasmettere niente comunque qualcosa viene trasmesso (vedi handshake) una volta stabilito un canale tls il client e server ogni tot si manderann dei messaggi di controllo (tipo sei ancora vivo o no)) CVE (common vulenerabilities and exposure, in sto db sono indicizzate tutte le vulenerabilità scoperte), questo attacco fa in modo di farsi rispondere dal server con informazioni contenute nella ram del server (info sensibili) sfruttando il fatto che nella request del client si chiedono il numero di lettere (ricordati fumetto bird,potato, hat) => buffer over-read. Se non si usa HSM il server è a rischio
	Attacco downgrade del server 
		-> si forza il server ad aprire un canale con vecchia versione di tls piena di bachi => attaccabile
		-Estensione SCSV, per prevenire attacchi di downgrade, dovrebbe esserer inviata dal client quando si apre una connessione downgraded

	Sicurezza di HTTP
		1.0 - controlli address-based , fa cacare per l'ip spoofing
			- basic authentication, l'accesso a una singola pagina richiede pwd e username, inviata dal client codificata in base64 (basta fare la decodifica e ricavo username e pwd)
			=> ALTAMENTE INSICURI perche si era ipotizzato che http venisse ustao sopra canali tls sicuri
		1.1 - introduce digest authentication


		HTTP Basic AuthN - slide 66
		HTTP digest authentication
			sfida asimmetrica che manda un keyed digest

	HTTP E TLS

		TLS then HTTP oppure HTTP then TLS: non sono equivalenti e hanno impatto su firewall e IDS

	USERNAME E PASSWORD IN UN FORM
		la parte da proteggere è il trasporto dei dati => la action del form deve essere protetta da https ma anche la pagine web che contiene il form!

	HTTP strict transport security (HSTS)

	SIstemi di pagamenti elettronico


FIREWALL e IDS/IPS

	Firewall = muro tagliafuoco/antincendio -> nb il firewall è quando non passa nulla (IMPOSSIBILE!) quindi va ispezionato cmq quello che si fa passare! esempio tazzina di zucchero attraverso il muro

	Ingress firewall = proteggo ciò in ingresso, seleziona i servizi che offro al esterno => collegamenti incoming
	
	Egress firewall =traffico in uscita dalla rete trusted (colleggamenti outgoing) => si usano per controllare cosa fanno le persone

	Distinzione facile da fare per servizi orientati al canale. NB il firewall NON si compra!! il firewall è un sistema cioè un insieme di componenti quindi si progetta! (al massimo si comprano i suoi componenti)

	L'indice di sicurezza e inversamente proporzionale al indice di funzionalità!

	1. il fw deve essere l'unico punto di contatto tra rete interna e esterna => tutto il trafico di rete deve uscire/entrare da un solo punto

	2. solo il traffico 'autorizzato' puo attraversare il fw!

	3. il fw deve essere un sistema altamente sicuro esso stesso

	Politiche di autorizzazione

	1. tutto cio che non è espressamente permesso è vietato! -> whitelisting
		maggior sicurezza piu difficile da gestire
	2. tutto cio che non è espressamente vietato è permesso! -> blacklisting
		minor sicurezza piu facile da gestire

	FW Elementi di Base

		- screening router (choke), da filtraggio
		- bastion host, nodi/server super sicuri con AUDITING del traffico
		- application gateway (proxy) per fare controlli a livello applicativo 
		- dual homed gateway, sistema con due connessioni di rete e routing disabled=> due schede di rete molto potenti

	A seconda del livello di rete a cui si fa sicurezza c'è un fw diverso

		- packet filter: livello IP, controlla gli headers
		- circuit gateway: esaminano gli stream tcp/udp a livello 4 senza entrare nel merito del traffico
		- application gateway, ispezionano i dati applicativi (si guarda proprio il comando alivello 	applicativo GET DELETE PUT)

	Architettura Screening Router

		Fa controlli di molto basso livello

	5/12/2019

		Packet filter
			ananalizza le info interne a un pacchetto

		Appllication level gateway: serie di proxy per ogni protocollo applicativo che si vuole lasciare passare, che esaminano i contenuto dei pacchetti al livello 5(app), è la solzione che offre maggiore sicurezza (disinzione tra formward proxy (egress) e reverse proxy(ingress)).Si posssno scrivere regole di filtraggio molto piu granulari rispetto a un packet filter. Purtroppo rrompe completamente il modello c/s 

		Circuit level gw (protegge da livello 3 e 4)
			crea un circuito tra c e s a livello trasporto 
			server piu protetti
				protegge da tutti gli attacchi che riguardano l'handshake tcp e la frammentazione di pacchetti ip
			puo autenticare i client (richiede modifiche applicative) SOCKS = egress firewall

		HTTP forward proxy

		Http reverse proxy -> fa da front end rispetto a chi vuole entrare passando poi le richieste al vero server

		16/12/2019

		IDS - Intrusion detection system

			indetificare attori che usano le rete senza le dovute autorizzazone oppure eccedono le autotrizzazioni a loro assegnate.

			Hp base : il pattern di comportamento del attaccante si differenzia da quello di tutti glia ltri utenti, altrimenti si ha difficolta a capirlo

			IDS passivi
				è sempre in ritardo, va a notare le tracce lasciate da un attacco, (Es: file di sistema alterati) (vedi TRIPWIRE), oppure not PACCHETTI gi transistai associabili ad attacchi noti ( attack signature)

			IDS attivi
				learning: si fanno delle statisctiche 
				monitoring: si analizzano le statisctiche
				reaction: confronto con paramentri statistisci il cui sui supermanto di una sogloia fda scatare l'allarme.
				NB fa decisa una soglia di tolleranza opportuna (una troppo bassa beccherà tutti gli attacchi ma anche i non) => trovare la soglia giusta è la parte piu complicata (I FALSI ALLARMI SONO INEVITABILI è pieno di falsi positivi) 

			Caratteristiche topologiche

				HIDS(host based ids)
					analisi dei log (del so delle applicazioni)
					attivazione di strumenti di monitoraggio interni del so

				NIDS(network based ids)

				SIV / LFM : Sistemy inegrity verifier, controlla di file/filesystem 
				Log file monitor: controlla i log


				Componenti di un NIDS

					sensor: controlla il traffico e i log individuando pattern sospetti
					director: coordina i sensor a fa delle deduzioni in base ai dati rilevati dal sensor => comunicano in rete (hanno bisogno di una rete cablata)
					ids message system

			IPS - Intrusion prevention system
				per velocizzare la risposta alle intrusione( esempio della metro e devOPs alle sichellese)

		NEXT GENERATION FIREWALL (NGFW)

			cerca di identificare le applicazioone decifrando e recifrando il traffico e indentifica gli utenti che stanno mandando il traffico , quindi verifcia se c'è una correlazioni tra i paccheti e l'applicazione o l'utente che li ha mandati, Identifica gli user con 802.1x,kerberos, authN e le app qualuqnue sia la porta

		UTM - Unified threat managemetn
			una magia che fa gia tutto, per i meno pratici, serve solo capire cosa ci hai messo dentro (firewall vpn ids ecc..)

		Honey POT / Honey net

			singolo server a bassa sicurezza per attirare i malintenzionati

	SICUREZZA DELLA POSTA ELETTRONICA

		MHS (message handling system)

			E' lunico sustema di larga scala che non è end to end, in mezzo ci sono nmila server:
				MUA - MESSAGE USER AGENT
				MSA - MESSAGE SUBMISSION AGENT- preleva il messaggio o linietta nella rete
				MTA - messagge transfer agent- 
				MTA CHAIN- ci sono n mta salti, alla fine l'ultimo mta metta nel message store del utente il messaggio - cè una catena per gestire l'eterogeneita tra reti 
				MS - messagge store

		email in client server

			mua -> msa -> msa -> .... (SMTP) push protocol
			MS -> MUA (POP, IMAP) pull protocol

		webmail( il piu usato)

			comodo e INSICURO

			web browser -> HTML/HTTP -> webserver: http engine + virtual MUA
			La posta ce l'ha il fornitore del servizio essendo nel web server di terzi!!
			SMTP 
				mta(25/tcp)
				msa(587/tcp)
			POP
				110/tcp
			IMAP
				143/tcp

			MIME 
				estensione multimediale (rfc-822)
				solo caratteri US-ASCII a 7 bit, righe terminate da <CR><LF>, messaggi con header e body

				termine riga: linux /n , mac <CR>, windows <CR><LF> (ambiguita tra OS)

				HEADER RFC 822
				 FROM != SENDER, from è logico (lo decidi tu), sender è operativo (quello reale)
				 RECEIVED -> fa vedere i nodi del sistema di posta elettrnonica che sono stati attraersati, tipo trace route

		Fare sicurezza su sto sistema è molto complicato

		Mail Spamming (ube , unsolicited bulk email) (uce, usolicited commercial email)

		1 messaggio su due di posta è di spam (55% circa)
		
		Strategie di spammer:
			nascondono il vero mittente (cambiando solo il campo from usando un mittende esistente a sua insaputa)
			spediscono spam tramite MTA speciali
				zombie o botnet
			content obfuscation	
				errori deliberati
				immagine invece che testo
				open mail relay

		OPEN MAIL RELAY
			è un sistema che accetta posta oltre che per i suoi utenti anche per terzi


		ESMTP - Extended SMTP

			invece che helo si dice ehlo

			smtp - auth: comando auth, serve ad autenticre un client prima di ricevere i messaggi, utile contro lo spamming 


		Protezione di smtp con tls -> start tls = opzione, prima si apre il canale smtp poi si converte in tls

		PGP - mondo underground (pretty good privacy)
			Phil zimmerman ha creato un programma come freeware

		Protocolli di accesso al MS

			MUA -> post office => authn del server e del utente

			POP -> fa solo authn del utente mediante pasword in chiaro, k-pop (kerberos)
			IMAP -> sempre pwd in chiaro ma puo usare otp

			POP3 - porta 110 -> tutto in chiaro
			APOP - sostiuisce pwd e username in chiaro con una sfida
			TLS per POP / IMAP - si crea prima pop imap poi si crea il canale tls
			




